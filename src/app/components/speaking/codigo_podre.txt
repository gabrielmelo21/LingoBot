import {interval, map, startWith, take, tap} from "rxjs";


cena: number = 1;
magic_book: boolean = false;
recordedAudioUrl: string | null = null;
recordStatus: string = '';
buttonEffect: boolean = false;
isMicActive = false;
isPaused = false;
recordingTimer: any = null;
elapsedTime: number = 0;
maxRecordingTime = 7;
showCountdown: boolean = false;
transcriptionResult: string = '';
isProcessing: boolean = false;
isRecording: boolean = false;
transcriptionText: string = '';
showResult = false;
userResponse: boolean = false;
countdownValue = 3;
countdownInterval: any = null;


resetCountdown() {
  if (this.countdownInterval) {
    clearInterval(this.countdownInterval);
    this.countdownInterval = null;
  }
  this.showCountdown = false;
  this.countdownValue = 3;
  this.logToMobileConsole('üîÅ Countdown resetado');
}


startAudioRecording() {

  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    this.logToMobileConsole('‚ùå Navegador n√£o suporta getUserMedia');
    return;
  }

  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(stream => {
      this.mediaRecorder = new MediaRecorder(stream);
      this.recordedChunks = [];
      this.mediaRecorder.start();
      this.buttonEffect = true;
      this.isRecording = true;
      this.isMicActive = true;
      this.isPaused = false;
      this.elapsedTime = 0;

      this.recordStatus = 'üéôÔ∏è Grava√ß√£o iniciada (0s/7s)';
      this.logToMobileConsole('üéôÔ∏è Grava√ß√£o iniciada');

      this.recordingTimer = setInterval(() => {
        this.elapsedTime++;
        this.recordStatus = `üéôÔ∏è Gravando (${this.elapsedTime}s/${this.maxRecordingTime}s)`;

        this.logToMobileConsole(`‚åõ Tempo: ${this.elapsedTime}s`);

        if (this.elapsedTime >= this.maxRecordingTime) {
          this.stopAudioRecording();
        }
      }, 1000);

      this.mediaRecorder.ondataavailable = (event) => {
        this.recordedChunks.push(event.data);
        this.logToMobileConsole('üîπ Chunk gravado');
      };

      this.mediaRecorder.onstop = () => {
        clearInterval(this.recordingTimer);

        const audioBlob = new Blob(this.recordedChunks, { type: 'audio/wav' });
        this.recordedAudioUrl = URL.createObjectURL(audioBlob);
        this.buttonEffect = false;
        this.isRecording = false;
        this.isMicActive = false;
        this.isPaused = false;

        this.recordStatus = 'üõë Enviando grava√ß√£o...';
        this.logToMobileConsole('üõë Grava√ß√£o parada e enviada');

        this.audioUrl = URL.createObjectURL(audioBlob);
        const previewAudio = new Audio(this.audioUrl);
        previewAudio.play();

        this.sendAudioToAPI(audioBlob);

        stream.getTracks().forEach(track => track.stop());
      };

      this.mediaRecorder.onpause = () => {
        this.buttonEffect = false;
        this.isPaused = true;
        this.recordStatus = '‚è∏Ô∏è Grava√ß√£o pausada';
        this.logToMobileConsole('‚è∏Ô∏è Grava√ß√£o pausada');
      };

      this.mediaRecorder.onresume = () => {
        this.buttonEffect = true;
        this.isPaused = false;
        this.recordStatus = '‚ñ∂Ô∏è Grava√ß√£o retomada';
        this.logToMobileConsole('‚ñ∂Ô∏è Grava√ß√£o retomada');
      };
    })
    .catch(error => {
      this.buttonEffect = false;
      this.logToMobileConsole('‚ùå Erro ao acessar microfone: ' + error.message);
    });
}

stopAudioRecording() {
  this.buttonEffect = false;
  if (this.mediaRecorder && this.isRecording) {
    if (this.recordingTimer) {
      clearInterval(this.recordingTimer);
    }
    this.mediaRecorder.stop();
    this.logToMobileConsole('üì• stopAudioRecording() chamado');
  }

  this.resetCountdownState(); // Garantia extra
}


handleMicClick() {
  if (this.isRecording || this.showCountdown) {
    this.logToMobileConsole('‚ö†Ô∏è J√° est√° gravando ou contando, clique ignorado');
    return;
  }

  this.logToMobileConsole('üé¨ Iniciando contagem regressiva');
  this.startCountdown();
}








checkUserResponse(): void {
  const user = this.normalizeText(this.transcriptionText);
  const correct = this.normalizeText(this.skill_phrase);
  this.userResponse = user === correct;

  this.logToMobileConsole(`üß† Checando resposta do usu√°rio: ${user} vs ${correct}`);
  this.logToMobileConsole(this.userResponse ? '‚úÖ Correto!' : '‚ùå Incorreto.');

  if (this.userResponse) {
  this.openMagicBook(); // fecha o livro
  this.skill_selected = false;
  this.logToMobileConsole("Skill Selected var  (deve ser false) -> " + this.skill_selected);
  this.cena = 2;
  this.logToMobileConsole("Cena atual " + this.cena);

  setTimeout(() => {
    this.cena = 1;
    this.logToMobileConsole("Cena atual " + this.cena);

    this.resetAll(); // üîÅ Reset ap√≥s a anima√ß√£o
    this.logToMobileConsole("Reset all. (No Acerto)")
  }, 4400);
} else {
  this.resetAll(); // üîÅ Reset imediato no erro
  this.logToMobileConsole("Reset all. (No Erro)")
}
}









resetCountdownState() {
  this.showCountdown = false;
  this.countdownValue = 3;
  this.cdr.detectChanges(); // for√ßa o Angular a atualizar o DOM
}



resetAll() {

  // Limpa grava√ß√£o, timers e estados
  if (this.mediaRecorder && this.isRecording) {
    this.mediaRecorder.stop();
  }

  if (this.recordingTimer) {
    clearInterval(this.recordingTimer);
    this.recordingTimer = null;
  }


  this.skill_selected = false;
  this.skill_selected_src = '';
  this.skill_selected_title = '';
  this.skill_selected_description = '';
  this.skill_phrase = '';
  //this.magic_book = false;
  this.mediaRecorder = null;
  this.recordedChunks = [];
  this.recordedAudioUrl = null;
  this.recordStatus = '';
  this.buttonEffect = false;
  this.isMicActive = false;
  this.isPaused = false;
  this.isRecording = false;
  this.elapsedTime = 0;
  this.recordingTimer && clearInterval(this.recordingTimer);
  this.recordingTimer = null;
  this.showCountdown = false;
  this.transcriptionResult = '';
  this.transcriptionText = '';
  this.isProcessing = false;
  this.showResult = false;
  this.userResponse = false;
  this.countdownValue = 3;

  this.logToMobileConsole('üîÑ Estado geral resetado');
  this.cdr.detectChanges(); // Atualiza a view se necess√°rio
}

